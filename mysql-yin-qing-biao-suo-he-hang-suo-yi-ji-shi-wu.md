---
description: 锁 类似于多线程互斥锁或者信号锁之类的.
---

# MYSQL引擎,表锁和行锁 以及事务

## MYSQL引擎

![&#x5B58;&#x50A8;&#x5F15;&#x64CE;&#x53CA;&#x5176;&#x7279;&#x70B9;](.gitbook/assets/ping-mu-kuai-zhao-20190511-09.33.25.png)

#### 只有INNODB引擎支持事务和多种索引, 一般都用它.

```sql
# 使用如下命令 来查看 当前 MYSQL 支持的存储引擎以及每个引擎的特点
mysql>  SHOW ENGINES;  # 添加\G 参数会显示的更清晰一些
mysql>  SHOW ENGINES \G

# 查看Mysql 默认存储引擎
mysql>  SHOW GLOBAL  variables like '%storage_engine%';   

#查看某张表的存储引擎
mysql>  SHOW CREATE TABLE 表名  ;

#对于表的存储结构的修改
mysql>  CREATE TABLE 表名 ( 列名  列类型, ...) ENGINE INNODB;   #创建设定表的引擎为 INNODB
mysql>  ALTER TABLE  表名 ENGINE  INNODB;        # 将某个已经存在的表,引擎修改为 INNODB
```

## 表锁和行锁

#### 锁状态: 锁定状态包括表所和行锁 两种. 可以通过系统状态变量\(status\) 来获得锁定总次数.

### MyISAM 引擎  表锁  : 需要改变表的存储类型才可以使用,  类型变更为\(MyISAM\) ,而且是串行的.

### INNODB  引擎  行锁 : 它和 MyISAM 差不多,  命令不区分,执行方式也没有太大区分.

#### MyISAM的表锁有两种模式:  _表共享读锁\(TABLE READ lock\)_  和    _表独占写锁 \(TABLE WRITE LOCK\)_

#### _一个用户对某个表加上了  读或写锁,  那么这个用户就不允许访问其他的表和库._

### 注意事项:

* 在 InnoDB 引擎中, 执行  mysql&gt; start transaction;  开始事件 会造成一个隐含的  _mysql&gt;_  UNLOCK tables ; 解锁操作 执行.  会解锁 已经锁定的行 或 表.

### 给表加锁 

1. **加共享读锁:** 加锁之后,其他用户只能读  , 但是会 阻塞写和修改操作, 等待解锁后执行. 但是给表加锁的用户可以正常访问,但是**不可以修改和插入数据, 而且不可以查看和修改 除加锁表之外的任何表!!.**
   1.  _**`mysql>   LOCK  TABLE  表名   READ` ;          \#正常加锁,**_
   2. _**`mysql>  LOCK   TABLE   表名  AS  别名    READ`;            \#加锁和加别名锁. 可以进行别名访问**_
   3. _**`mysql>  LOCK  TABLE   表名1 READ , 表名2 WRITE;`       \# 同时锁多个表, 给出表名和锁的类型.**_
   4. _\*\*\*\*_
2. **表 独占写锁:**  加锁之后, 其他用户的  读和写  都会被阻塞, 等待解锁后执行. 但是给表加锁的用户可以正常访问和修改以及插入数据. **但是不可以查看 除加锁表之外的任何表!!!**
   1. _**`mysql>  LOCK   TABLE   表名  WRITE ;`          \#正常加锁**_
   2. _**`mysql>  LOCK    TABLE   表名   AS 别名  WRITE` ;        \#也是别民和正常加锁**_
   3. _**`mysql>  LOCK  TABLE   表名1 READ , 表名2 WRITE;`        \# 同时锁多个表, 给出表名和锁的类型.**_

### 解锁     

* _`mysql>   UNLOCK  TABLES;`_   

### 并发插入

#### MyISAM  表的读和写是串行的,  但这是就总体而言的.  在一定条件下   MyISAM 表也支持查询和插入操作的并发进行.

#### SyISAM 存储引擎有一个系统变量  concurrent\_insert,  专门用以控制其并发插入的行为, 值分别为 0, 1 ,2 .其中 1 是是默认值, 在存储中表现为  VALUE =  AUTO     

* 当concurrent\_insert 设置为**0** 时,  不允许并发插入
* 当concurrent\_insert 设置为**1** 时,  如果MyISAM 表中没有**空洞**_\( 即表的中间没有被删除的行 \)_, MyISAM**允许在一个进程读表的同时**,  另一个**进程**从**表尾插入记录**.  这也是 **MySQL** 的默认设置.
* 当concurrent\_insert  设置为**2** 时, 无论 MyISAM 表中有没有**空洞,  都允许在表尾并发插入记录.**

```sql
# 首先需要设置好 我们所需要并发插入的系统变量的行为级别.  0   1   2
mysql>  USE  test;        # 首先进入一个库
mysql>  SHOW GLOBAL variables  like 'concurrent_insert';  #查询并发级别,默认的 AUTO  = 1;
mysql>  SET  GLOBAL  concurrent_insert = 2;       #这样来修改系统变量级别.



--------- 读并发 , concurrent_insert 设置为2  --------------------------
# 设置一个 允许并发 读  的一个锁.(首先我需要在一个库内,以及完成了设置并发变量操作的值为 2 )
mysql>  SET  GLOBAL  concurrent_insert = 2;
mysql> LOCK TABLE  表名 READ LOCAL;     # 后面的LOCAL,是表示并发的关键字. 前面是读锁

# 接下里说明执行了 允许并发读  命令之后会发生的事情: (用户 A 执行了并发锁 命令)
    # 执行 加锁读并发 的用户 A , 不允许向表内插入数据和修改数据,只能读取,而且读取的是执行命令之后
    # 系统生成的表快照, 也就是说, 其他用户是可以对 加了 读锁并发 的表进行任何操作(增删改查都可以),
    # 但是 A 用户是看不到 其他用户所进行的任何修改, 他只可以查看当时上锁的表内的数据.
# A 用户执行任何 修改,插入,删除 语句都会报错  1099这错误.
# 其他用户毫无影响,任何命令都可以执行.

#A 用户执行 解锁操作之后会发生的情况:
mysql> UNLOCK TABLES;

# A 用户一直在查看的是系统生成的表快照, 一旦解锁,快照消失. A用户访问的就是真正的表了.
# 对其他用户毫无影响.
------------------------------------------
***************************************


--------- 读并发 , concurrent_insert 设置为1  --------------------------
# 设置一个 允许并发 读  的一个锁.(首先我需要在一个库内,以及完成了设置并发变量操作的值为 1 )
mysql>  SET  GLOBAL  concurrent_insert = 1;
mysql> LOCK TABLE  cb  READ LOCAL;

# 用户A 执行了以上  读并发命令, 并且设定值为1 , (默认也是1)
# 假设这个表 cb  曾经被删除过数据, 那么 并发命令执行后,其他用户的 写操作会被阻塞, 读操作可以进行.
# 那么A 用户可以进行查询操作, 但是也无法进行修改和插入操作. 而且也无法查看和修改其他表.

#A用户执行解锁命令
mysql> UNLOCK  TABLES;

#执行解锁命令之后, 其他用户阻塞的 修改操作会被直接执行.  A用户也可以进行任意操作了.
------------------------------------------
***************************************
```

### MyISAM 引擎  锁调度

#### 当一个进程请求某个 MyISAM表的 '读锁' ,  同时另外一个进程也请求同一个表的 '写锁' , MyISAM 会进行如下处理:

> 写进程先获得锁.   即使 读锁 请求先到 锁等待队列, 写锁 请求后到,  那么写锁也会插到读锁队列之前, 进行优先执行.           
>
> MyISAM  认为 写请求比 读请求更重要.  MyISAM 不太适合有大量更新操作和查询操作的原因, 因为大量的更新操作会造成查询操作很难获得读锁, 从而可能永远阻塞.
>
> #### 解决方法
>
> 执行 **`mysql>  SET low_priority_updates = 1`** ;        使该连接发出的更新请求\(写锁\) 优先级降低. 
>
> 其中  INSERT , DELETE 也可以通过此方法指定.\(  `low_priority_inserts = 1`,   `low_priority_deletes = 1`\)



## 事务   \(Transactions\)

**将所有更改的数据整体的向数据库提交, 这就是事务**

_**事务应该具有4个属性:  原子性, 一致性, 隔离性, 持久性.**_

* _**原子性:**_   两步或N步操作, 逻辑上不可分割. 要么成功,要么都不成功.
* _**一致性:**_   操作前后,值的变化, 逻辑上成立. \(出现溢出就不算成立\)
* _**隔离性:**_ 事务结束前,每一步的操作带来的影响,别的会话看不见.
* _**持久性:**_  事务一旦完成, 无法撤销, \(未完成时 也就是失败了,可以撤销\).

_**目前一般使用 Innodb 引擎**_ 

#### 如果未开启事务,只 执行 正常的 SQL 语句, 那么当你执行成功后 ,数据库会隐式的帮你 提交. 

#### 如果数据库不隐式提交,那么你所做的更改就不会出现在表内,  而是在你调用 commit ;  显示提交后,你的 SQL 语句才会作用到表上.

### 注意事项:

* 在 InnoDB 引擎中, 执行  mysql&gt; start transaction;  开始事件 会造成一个隐含的  _mysql&gt;_  UNLOCK tables ; 解锁操作 执行.  会解锁 已经锁定的行 或 表.

### 事务开启, 提交, 回滚. 关闭隐式提交

**回滚:**   回到事务发生之前的数据状态.  通过 rollback;

```sql
#开启事务  , 执行之后会隐式的将自动提交关闭,也就是将 autocommit 设置为0, 
# 注意: 当表或库是 Innodb引擎的时候, 执行开始事务,会隐式调用一次 unlock tables 将锁住的表解锁.
mysql> start transaction;

#事务完成,提交, 结束事务, 将事务操作应用在表上.
mysql> commit;

#提交事务之后 重新开启了新的事务
mysql> commit and chain;    # 就是把现在执行的事务提交上去, 然后在开启一个新的事务


#事务出错,手动回滚
mysql> rollback;

# 事务回滚, 然后断开和客户端的连接
# mysql>  rollback and release;     #这条语句在终端下无效.也可能只允许在程序的 api调用中实现

# 回滚到还原点. (无论是否在执行事务,都可以使用,但是需要有还原点)
mysql> rollback to savepoint  还原点名;   #还原点需要在 自动提交关闭状态下 使用 savepoint 来创建

# 关闭 数据库的隐式 提交属性, (这是数据库默认开启的属性)
mysql> SET autocommit = 0;      #0 是关闭, 1是开启.
     # 一旦关闭了自动提交,那么无论是否在进行事务, 你的语句都不会作用在表上, 必须显示调用提交.commit
```

#### 当你正在使用 开启事务 进行SQL语句的时候,  只要你不提交.那么 你做的所有更改和操作 都不会作用在表上, 其他人也看不见你所做的任何修改和操作.   但是一旦提交,  那么其他的就可以看得见你所做的任何更改了操作. 而且也会作用在表上\(或库上\).



## 还原点 

还原点其实就是标记, 可以让我们回到标记的位置, 那个时候的数据. 跟 快照 类似. 

还原点可以在事务中使用, 也可以在关闭自动提交后使用.

#### !!! 注意事项 !!!!    

* 一旦你回滚到某个还原点,  那么这个还原点之后 所有创建的还原点都会消失.
* 一旦你提交事务 或 开启自动提交  , 那么你之前所有创建的还原点会全部消失.

### 创建还原点和回滚到还原点.

```sql
# 还原点关键字是  savepoint ,  主要用在事务内,也可以在关闭自动提交后正常的使用.
mysql>  SET autocommit = 0;    # 这里是关闭了自动提交,  也可以替换成开启事务.
mysql>  INSERT INTO  userinfo  VALUES (6, 'test1','128');

mysql>   savepoint s1;        # 这里创建了还原点 s1 

mysql>  INSERT  INTO  userinfo  VALUES (7, 'test2','129');
mysql>   savepoint  s2;      #又创建了一个还原点s2


# 回滚到还原点. (无论是否在执行事务,都可以使用,但是需要有还原点,而且关闭自动提交)
mysql> rollback to savepoint  s1 ;   # 回滚到上面创建的还原点 s1 的位置

```

